<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Credit Note</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background-attachment: fixed;
            color: #000;
            line-height: 1.5;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            z-index: -1;
        }
        
        .page {
            max-width: 1200px;
            margin: 40px auto;
            padding: 20px;
            background: #fff;
            border: 1px solid #ccc;
            box-sizing: border-box;
        }
        
        h1 {
            text-align: center;
            margin: 0;
            padding-bottom: 10px;
        }
        
        .top-menu {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .left-menu {
            display: flex;
            gap: 3px;
        }
        
        .right-menu {
            display: flex;
            gap: 3px;
        }
        
        .top-menu-btn {
            font-size: 0.9rem;
            padding: 5px 10px;
            margin: 0 3px;
            cursor: pointer;
            border: 1px solid #ccc;
            background: #fff;
            color: #000;
            border-radius: 3px;
            min-width: 80px;
            height: 30px;
            line-height: 1.2;
        }
        
        .top-menu-btn:hover {
            background: #f0f0f0;
            border-color: #999;
        }
        
        .top-menu-btn.mode-btn.selected {
            background: black;
            color: white;
            border-color: black;
        }
        
        .split-btn {
            width: 20px;
            height: 20px;
            font-size: 12px;
            padding: 0;
            border: 1px solid #ccc;
            background: #fff;
            cursor: pointer;
            border-radius: 3px;
            box-sizing: border-box;
        }
        
        .split-btn:hover {
            background: #f0f0f0;
            border-color: #999;
        }
        
        .year-display {
            font-size: 0.9rem;
            font-weight: 600;
            color: #000;
            min-width: 50px;
            text-align: center;
            padding: 0 5px;
            margin: 0 3px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            height: 30px;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
        }
        
        .week-display {
            font-size: 0.9rem;
            font-weight: 600;
            color: #000;
            min-width: 50px;
            text-align: center;
            padding: 0 5px;
            margin: 0 3px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            height: 30px;
            background: #f8f8f8;
            border: 1px solid #e0e0e0;
            border-radius: 3px;
            cursor: help;
        }
        
        .week-display:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }
        
        .year-btn {
            min-width: 30px;
            width: 30px;
            padding: 5px;
        }

        .order-table-container {
            margin-top: 20px;
            margin-bottom: 120px;
            overflow-x: auto;
            width: 100%;
            max-width: 100%;
            position: relative;
        }
        
        #orderTable {
            width: 100%;
            table-layout: fixed;
            border-collapse: collapse;
            border: 1px solid #ccc;
            font-size: 0.9rem;
        }
        
        #orderTable th,
        #orderTable td {
            border: 1px solid #ccc;
            padding: 8px;
            text-align: center;
            vertical-align: middle;
        }
        
        #orderTable th {
            background-color: #f5f5f5;
            font-weight: bold;
        }
        
        
        
        #orderTable td {
            font-size: 0.9rem;
        }
        
        .bottom-buttons {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #fff;
            border-top: 1px solid #e0e0e0;
            padding: 15px;
            z-index: 1000;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
        }

        .expand-handle {
            position: absolute;
            top: -15px;
            left: 20px;
            z-index: 10;
        }

        .expand-btn {
            font-size: 0.8rem;
            padding: 4px 12px;
            cursor: pointer;
            border: 1px solid #ccc;
            background: #f8f8f8;
            color: #666;
            border-radius: 8px 8px 0 0;
            min-width: 40px;
            height: 20px;
            line-height: 1;
            transition: all 0.2s ease;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
        }

        .expand-btn:hover {
            background: #e8e8e8;
            border-color: #999;
            box-shadow: 0 -3px 6px rgba(0,0,0,0.15);
        }

        .expand-btn.expanded {
            transform: rotate(180deg);
            background: #e0e0e0;
        }

        .main-button-group {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            background: #fff;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
        }

        .detail-button-area {
            margin-top: 10px;
            padding: 12px;
            background: #f9f9f9;
            border: 1px solid #e0e0e0;
            border-radius: 5px;
            animation: slideDown 0.3s ease;
            display: flex;
            gap: 8px;
            justify-content: center;
            flex-wrap: wrap;
        }

    .detail-button-area button {
      margin: 0;
    }
    
    /* 모달 창 스타일 */
    .modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
    }

    .modal-content {
      background-color: #fefefe;
      margin: 2% auto;
      padding: 0;
      border: 1px solid #888;
      width: 500px;
      max-width: 90%;
      border-radius: 5px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
    }

    .modal-header {
      padding: 15px 20px;
      background-color: #f8f8f8;
      border-bottom: 1px solid #ddd;
      border-radius: 5px 5px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h3 {
      margin: 0;
      color: #333;
    }

    .close {
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
    }

    .close:hover {
      color: #000;
    }

    /* Delete 모달 X 버튼 전용 스타일 */
    .close-delete-creditnote {
      color: #aaa;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .close-delete-creditnote:hover {
      color: #000;
    }

    .modal-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }

    .modal-footer {
      padding: 15px 20px;
      background-color: #f8f8f8;
      border-top: 1px solid #ddd;
      border-radius: 0 0 5px 5px;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    /* 모달 내부 버튼 호버 효과 */
    .modal button:hover {
      background: #f0f0f0;
      border-color: #999;
    }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }



        .deleteButton {
            font-size: 0.75rem;
            padding: 1px 3px;
            cursor: pointer;
            margin: 0;
            display: inline-block;
            width: 22px;
            height: 18px;
            min-width: 22px;
            border: 1px solid #ccc;
            background: #fff;
            color: #000;
            border-radius: 3px;
            line-height: 1.2;
            box-sizing: border-box;
            text-align: center;
        }

        .deleteButton:hover {
            background: #f0f0f0;
            border-color: #999;
        }

        
        /* 열 폭 설정 - 7개 열 모두 90px */
        #orderTable th:nth-child(1), #orderTable td:nth-child(1) { width: 90px; max-width: 90px; min-width: 90px; text-align: center; white-space: nowrap; overflow: hidden; }
        #orderTable th:nth-child(2), #orderTable td:nth-child(2) { width: 90px; max-width: 90px; min-width: 90px; text-align: center; white-space: nowrap; overflow: hidden; }
        #orderTable th:nth-child(3), #orderTable td:nth-child(3) { width: 90px; max-width: 90px; min-width: 90px; text-align: center; white-space: nowrap; overflow: hidden; }
        #orderTable th:nth-child(4), #orderTable td:nth-child(4) { width: 90px; max-width: 90px; min-width: 90px; text-align: center; white-space: nowrap; overflow: hidden; }
        #orderTable th:nth-child(5), #orderTable td:nth-child(5) { width: 90px; max-width: 90px; min-width: 90px; text-align: center; white-space: nowrap; overflow: hidden; }
        #orderTable th:nth-child(6), #orderTable td:nth-child(6) { width: 90px; max-width: 90px; min-width: 90px; text-align: center; white-space: nowrap; overflow: hidden; }
        #orderTable th:nth-child(7), #orderTable td:nth-child(7) { width: 90px; max-width: 90px; min-width: 90px; text-align: center; white-space: nowrap; overflow: hidden; }
        #orderTable th:nth-child(8), #orderTable td:nth-child(8) { width: 45px; max-width: 45px; min-width: 45px; text-align: center; white-space: nowrap; overflow: hidden; }
        #orderTable th:nth-child(9), #orderTable td:nth-child(9) { width: 90px; max-width: 90px; min-width: 90px; text-align: center; white-space: nowrap; overflow: hidden; }
        
        /* 테이블 컨테이너 스크롤 설정 */
        .table-container {
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
        }
        
        /* 테이블 헤더 고정 */
        #orderTable {
            position: relative;
            margin-bottom: 0;
        }
        
        #orderTable thead {
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        #orderTable thead th {
            position: sticky;
            top: 0;
            background-color: #f8f9fa;
            z-index: 100;
            border-bottom: 2px solid #dee2e6;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* 체크박스가 있는 셀 정렬 통일 */
        #orderTable td {
            text-align: center;
            vertical-align: middle;
        }
        
        /* 체크박스 스타일 - production.html과 동일 */
        .row-checkbox {
            transform: scale(1.2);
            cursor: pointer;
            display: block;
            margin: 0 auto;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border: 1px solid #ccc;
            border-radius: 2px;
            background-color: white; /* 기본 상태: 흰색 */
            position: relative;
        }
        
        /* 체크된 상태: 파란색 */
        .row-checkbox:checked {
            background-color: #007bff;
            border-color: #007bff;
        }
        
        /* 체크마크 표시 */
        .row-checkbox:checked::after {
            content: '✓';
            position: absolute;
            top: -1px;
            left: 1px;
            color: white;
            font-size: 10px;
            font-weight: bold;
        }
        
        /* 호버 효과 */
        .row-checkbox:hover {
            border-color: #007bff;
        }
        
        /* + 박스 스타일 - 체크박스와 같은 크기 */
        .plus-box {
            width: 12px;
            height: 12px;
            border: 1px solid #ccc;
            border-radius: 2px;
            background-color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: #333;
            margin: 0 auto;
            cursor: pointer;
        }
        
        /* + 박스 호버 효과 */
        .plus-box:hover {
            border-color: #007bff;
            background-color: #f8f9fa;
        }
        
        
    </style>
</head>
<body>
<div class="page">
    <h1>Credit Note</h1>

    <div class="top-menu">
        <div class="left-menu">
            <button type="button" onclick="location.href='eltrokorea9.html'" class="top-menu-btn">Home</button>
            
            <button type="button" id="yearDownBtn" class="top-menu-btn year-btn">▼</button>
            <span id="yearDisplay" class="year-display">2025</span>
            <button type="button" id="yearUpBtn" class="top-menu-btn year-btn">▲</button>
        </div>
        
        <div class="right-menu">
        </div>
    </div>

    <div class="order-table-container">
        <div class="table-container">
            <table id="orderTable">
            <thead>
         <tr>
           <th></th>
           <th>Company</th>
           <th>DeliveryNo</th>
           <th>InvoiceNo</th>
           <th>InvoiceDate</th>
           <th>EURO(€)</th>
           <th>Dollar ($)</th>
           <th>Check</th>
           <th>Action</th>
         </tr>
            </thead>
            <tbody id="orderTableBody">
                <!-- 테이블은 JavaScript로 동적 생성 -->
            </tbody>
        </table>
        </div>
    </div>
</div>

<!-- 하단 버튼 영역 -->
<div class="bottom-buttons">
    <div class="expand-handle">
        <button id="expandButton" type="button" class="expand-btn">▼</button>
    </div>
    
    <div class="main-button-group">
        <div style="margin-left: auto; display: flex; gap: 8px;">
            <button type="button" onclick="location.href='creditnoteupdate.html'" class="top-menu-btn">Update</button>
        </div>
    </div>

    <div id="detailButtonArea" class="detail-button-area" style="display: none;">
        <!-- 필요시 추가 버튼들 -->
    </div>
</div>

<script>
    // 년도 선택 초기화
    let currentYear = new Date().getFullYear();

    const yearDisplay = document.getElementById("yearDisplay");
    const yearUpBtn = document.getElementById("yearUpBtn");
    const yearDownBtn = document.getElementById("yearDownBtn");

    // 년도 변경 공통 함수
    function updateYear(newYear) {
        currentYear = newYear;
        yearDisplay.textContent = currentYear;
        generateCreditNoteTable();
    }
    
    // 년도 증가 버튼
    yearUpBtn.addEventListener("click", () => {
        updateYear(currentYear + 1);
    });

    // 년도 감소 버튼
    yearDownBtn.addEventListener("click", () => {
        if (currentYear > 2020) {
            updateYear(currentYear - 1);
        }
    });

    // 공통 데이터 로드 함수
    async function loadData(endpoint, dataType) {
        try {
            const response = await fetch(endpoint);
            if (response.ok) {
                return await response.json();
            } else {
                console.error(`${dataType} 응답 실패:`, response.status, response.statusText);
                return [];
            }
        } catch (error) {
            console.error(`${dataType} 데이터 로드 실패:`, error);
            return [];
        }
    }
    
    // Credit Note 데이터 로드 함수
    async function loadCreditNoteData() {
        return await loadData('/api/creditnote', 'Credit Note');
    }
    
    // Order 데이터를 로드하는 함수
    async function loadOrderData() {
        return await loadData('/api/orders', 'Order');
    }
    
    // invoiceno로 order 데이터를 찾는 함수
    function findOrderByInvoiceNo(orderData, invoiceNo) {
        if (!invoiceNo || !orderData) {
            return null;
        }
        
        // 모든 items를 평면화하여 검색
        const allItems = orderData.flatMap(order => order.items || []);
        const foundItem = allItems.find(item => item.invoiceno === invoiceNo);
        
        
        return foundItem || null;
    }
    
    // 한 달 전 invoicedate로 order 데이터를 찾는 함수
    function findOrdersByPreviousMonthInvoiceDate(orderData, month, year) {
        if (!orderData) return [];
        
        // 현재 월의 한 달 전 계산
        const currentMonth = getMonthNumber(month);
        const previousMonth = currentMonth === 1 ? 12 : currentMonth - 1;
        const previousYear = currentMonth === 1 ? year - 1 : year;
        
        // SM 모드 필터링 및 날짜 매칭
        return orderData
            .filter(order => order.mode && ['SM-B', 'SM-C'].includes(order.mode))
            .flatMap(order => order.items || [])
            .filter(item => {
                if (!item.invoicedate) return false;
                
                            const dateParts = item.invoicedate.split('.');
                if (dateParts.length < 3) return false;
                
                                const itemMonth = parseInt(dateParts[1]);
                                const itemYear = parseInt(dateParts[2]);
                                
                return itemYear === previousYear && itemMonth === previousMonth;
            });
    }

    // 카테고리 1 아이템들의 commission 계산 함수
    function calculateCategory1Commission(items) {
        if (!items || items.length === 0) {
            return 0;
        }
        
        const COMMISSION_RATES = {
            LOW_PHD: { threshold: 5.5, rate: 0.2 },
            HIGH_PHD: { threshold: 6.0, rate: 0.15 }
        };
        
        return items.reduce((total, item) => {
            const phd = parseFloat(item.phd);
            const deliveredkg = parseFloat(item.deliveredkg);
            
            if (isNaN(phd) || isNaN(deliveredkg)) return total;
            
            let rate = 0;
            if (phd <= COMMISSION_RATES.LOW_PHD.threshold) {
                rate = COMMISSION_RATES.LOW_PHD.rate;
            } else if (phd >= COMMISSION_RATES.HIGH_PHD.threshold) {
                rate = COMMISSION_RATES.HIGH_PHD.rate;
            }
            
            return total + (deliveredkg * rate);
        }, 0);
    }

    // creditnote.html에서 l/pno를 확인하여 Less Payment 찾는 함수
    function findLessPaymentItems(creditNoteData, month, year) {
        if (!creditNoteData) return [];
        
        const monthNumber = getMonthNumber(month);
        if (monthNumber === 0) return [];
        
        return creditNoteData
            .filter(item => item['l/pno'] && item['l/pdate'])
            .filter(item => {
                const dateParts = item['l/pdate'].split('.');
                if (dateParts.length < 3) return false;
                
                const isYearFirst = dateParts[0].length === 4;
                const itemYear = parseInt(isYearFirst ? dateParts[0] : dateParts[2]);
                const itemMonth = parseInt(dateParts[1]);
                
                return itemYear === year && itemMonth === monthNumber;
            })
            .map(item => ({
                deliveryNo: '',
                            invoiceno: item['l/pno'],
                            invoicedate: item['l/pdate'],
                            'p/iprice': 0,
                            invoiceprice: 0,
                            'l/pdollar': item['l/pdollar'] || 0,
                            'l/peuro': item['l/peuro'] || ''
            }));
    }

    // creditnote.html에서 o/pno를 확인하여 추가 Over Payment 찾는 함수
    function findAdditionalOverPayments(creditNoteData, existingOverPayments, month, year) {
        if (!creditNoteData) return [];
        
        const monthNumber = getMonthNumber(month);
        if (monthNumber === 0) return [];
        
        const existingInvoiceNos = new Set(existingOverPayments.map(item => item.invoiceno));
        
        return creditNoteData
            .filter(item => item['o/pno'] && item['o/pdate'])
            .filter(item => {
                const dateParts = item['o/pdate'].split('.');
                if (dateParts.length < 3) return false;
                
                const isYearFirst = dateParts[0].length === 4;
                const itemYear = parseInt(isYearFirst ? dateParts[0] : dateParts[2]);
                const itemMonth = parseInt(dateParts[1]);
                
                return itemYear === year && itemMonth === monthNumber;
            })
            .filter(item => !existingInvoiceNos.has(item['o/pno']))
            .map(item => ({
                deliveryNo: '',
                                invoiceno: item['o/pno'],
                                invoicedate: item['o/pdate'],
                                'p/iprice': 0,
                                invoiceprice: 0,
                                'o/pdollar': item['o/pdollar'] || 0
            }));
    }

    // Over Payment 아이템들을 찾는 함수
    function findOverPaymentItems(orderData, month, year) {
        if (!orderData) return [];
        
        const monthNumber = getMonthNumber(month);
        if (monthNumber === 0) return [];
        
        const seenDeliveryNos = new Set();
        
        return orderData
            .filter(order => order.mode === 'NT')
            .flatMap(order => order.items || [])
            .filter(item => {
                // 필수 필드 확인
                if (!item.invoicedate || !item.deliveryNo || !item.invoiceno) return false;
                
                // 날짜 조건
                            const dateParts = item.invoicedate.split('.');
                if (dateParts.length < 3) return false;
                
                                const itemMonth = parseInt(dateParts[1]);
                                const itemYear = parseInt(dateParts[2]);
                                
                if (itemYear !== year || itemMonth !== monthNumber) return false;
                
                // 금액 조건: (piprice + piprice2 - invoiceprice) > 0
                const piprice = parseFloat(item['p/iprice']) || 0;
                const piprice2 = parseFloat(item['p/iprice2']) || 0;
                const invoiceprice = parseFloat(item['invoiceprice']) || 0;
                const overPaymentValue = piprice + piprice2 - invoiceprice;
                
                return overPaymentValue > 0;
            })
            .filter(item => {
                // deliveryNo당 한 행만
                if (seenDeliveryNos.has(item.deliveryNo)) return false;
                seenDeliveryNos.add(item.deliveryNo);
                return true;
            });
    }

    // 월 이름을 숫자로 변환하는 함수
    function getMonthNumber(monthName) {
        const monthMap = {
            '1월': 1, '2월': 2, '3월': 3, '4월': 4, '5월': 5, '6월': 6,
            '7월': 7, '8월': 8, '9월': 9, '10월': 10, '11월': 11, '12월': 12
        };
        return monthMap[monthName] || 0;
    }

    // 해당 월의 nttotalcommission 값을 찾는 함수
    function findNtTotalCommission(creditNoteData, monthName, year) {
        const monthNumber = getMonthNumber(monthName);
        if (monthNumber === 0) return '';

        const matchingItem = creditNoteData.find(item => {
            if (!item['c/ndate']) return false;
            
                const dateParts = item['c/ndate'].split('.');
            if (dateParts.length < 2) return false;
            
                    const itemYear = parseInt(dateParts[0]);
                    const itemMonth = parseInt(dateParts[1]);
                    
            return itemYear === year && itemMonth === monthNumber;
        });

        return matchingItem?.data?.nttotalcommission || '';
    }
    
    // SM 데이터를 찾는 함수
    function findSmData(creditNoteData, monthName, year) {
        const monthNumber = getMonthNumber(monthName);
        if (monthNumber === 0) return null;

        // 해당 월의 모든 Credit Note 찾기
        const monthCreditNotes = creditNoteData.filter(item => {
            if (!item['c/ndate']) return false;
            
                const dateParts = item['c/ndate'].split('.');
            if (dateParts.length < 2) return false;
            
                    const itemYear = parseInt(dateParts[0]);
                    const itemMonth = parseInt(dateParts[1]);
                    
            return itemYear === year && itemMonth === monthNumber;
        });

        if (monthCreditNotes.length === 0) return null;

        // 첫 번째 Credit Note의 data를 기본으로 사용
        const result = { ...monthCreditNotes[0].data };

        // totalcommission 합산
        const totalCommissionSum = monthCreditNotes.reduce((sum, creditNote) => {
            return sum + (parseFloat(creditNote.data?.totalcommission) || 0);
        }, 0);
        
            result.totalcommission = totalCommissionSum.toString();

        return result;
    }

    // 테이블 동적 생성 함수
    async function generateCreditNoteTable() {
        const tbody = document.getElementById('orderTableBody');
        // 기존 데이터가 있으면 모두 제거
        tbody.innerHTML = '';
        
        // Credit Note 데이터 로드
        const creditNoteData = await loadCreditNoteData();
        
        // Order 데이터 로드
        const orderData = await loadOrderData();
        
        const months = ['1월', '2월', '3월', '4월', '5월', '6월', 
                       '7월', '8월', '9월', '10월', '11월', '12월'];
        
        months.forEach((month) => {
            try {
                let monthRowCount = 0;
                let firstRowOfMonth = null;
            
            // 카테고리1 (SM) - 한 달 전 invoicedate 데이터 로드
            const previousMonthItems = findOrdersByPreviousMonthInvoiceDate(orderData, month, currentYear);
            
            // 카테고리 1의 commission 계산
            const category1Commission = calculateCategory1Commission(previousMonthItems);
            
            if (previousMonthItems.length > 0) {
                // deliveryno별로 그룹화
                const groupedByDeliveryNo = {};
                for (const item of previousMonthItems) {
                        const deliveryNo = item.deliveryNo;
                    if (!groupedByDeliveryNo[deliveryNo]) {
                        groupedByDeliveryNo[deliveryNo] = [];
                    }
                    groupedByDeliveryNo[deliveryNo].push(item);
                }
                
                // 각 deliveryno별로 1개 행만 생성
                const deliveryNos = Object.keys(groupedByDeliveryNo);
                    const createRow = (item, items, isFirst, rowspan = '') => {
                        const row = document.createElement('tr');
                        const monthCell = isFirst ? `<td rowspan="${deliveryNos.length}">${month}</td>` : '';
                        
                        // 각 deliveryNo별 commission 계산 (항상 euro로 표시)
                        const deliveryCommission = calculateCategory1Commission(items);
                        const euroValue = deliveryCommission > 0 ? deliveryCommission.toFixed(2) : '';
                        // 모든 행에 commission이 있으면 노란색 배경 적용
                        const euroCell = `<td contenteditable="false" ${deliveryCommission > 0 ? 'style="background-color: #ffff00;"' : ''}>${euroValue}</td>`;
                        
                        row.innerHTML = `
                            ${monthCell}
                            <td contenteditable="false">SM</td>
                            <td contenteditable="false">${item.deliveryNo || ''}</td>
                            <td contenteditable="false">${item.invoiceno || ''}</td>
                            <td contenteditable="false">${item.invoicedate || ''}</td>
                            ${euroCell}
                            <td contenteditable="false"></td>
                            <td contenteditable="false"></td>
                            <td contenteditable="false"></td>
                        `;
                        return row;
                    };
                    
                    for (let i = 0; i < deliveryNos.length; i++) {
                        const items = groupedByDeliveryNo[deliveryNos[i]];
                        const firstItem = items[0];
                        const category1Row = createRow(firstItem, items, i === 0);
                        
                        if (i === 0) firstRowOfMonth = category1Row;
                    
                    tbody.appendChild(category1Row);
                    monthRowCount++;
                }
            } else {
                // 데이터가 없어도 카테고리1 빈 행은 항상 생성
                const category1Row = document.createElement('tr');
                category1Row.innerHTML = `
                    <td rowspan="1">${month}</td>
                    <td contenteditable="false">SM</td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                `;
                tbody.appendChild(category1Row);
                monthRowCount++;
                firstRowOfMonth = category1Row;
            }
            
            // 카테고리2 (SM) - 실제 데이터가 로드되는 SM 그룹
            const smData = findSmData(creditNoteData, month, currentYear);
            let category2RowCount = 0;
            
            // SM 데이터가 있고 실제 SM 데이터가 있는지 확인 (totalcommission 제외)
            const hasSmData = smData && (
                smData.invoiceno1 || smData.smcommission1 || smData.smtotalcommission
            );
            
            
            if (hasSmData) {
                // invoiceno1~7과 smcommission1~7 처리
                const invoiceRows = Array.from({length: 7}, (_, i) => smData[`invoiceno${i + 1}`]).filter(Boolean);
                const commissionRows = Array.from({length: 7}, (_, i) => smData[`smcommission${i + 1}`]).filter(Boolean);
                
                // smtotalcommission 추가
                if (smData.smtotalcommission) {
                    commissionRows.push(smData.smtotalcommission);
                }
                
                const maxRows = Math.max(invoiceRows.length, commissionRows.length);
                
                // 날짜 찾기 함수 (SM 카테고리용)
                const findInvoiceDate = (invoiceNo) => {
                    if (!invoiceNo) return '';
                    
                    const matchedOrder = findOrderByInvoiceNo(orderData, invoiceNo);
                    return matchedOrder?.invoicedate || '';
                };
                
                // 행 생성 함수
                const createSmRow = (i, invoiceNo, commission) => {
                    const row = document.createElement('tr');
                    const matchedOrder = findOrderByInvoiceNo(orderData, invoiceNo);
                    const deliveryNo = matchedOrder?.deliveryNo || '';
                    const finalInvoiceDate = findInvoiceDate(invoiceNo);
                    
                    const isFirst = i === 0;
                    const isLast = i === maxRows - 1;
                    const monthCell = isFirst ? `<td rowspan="${maxRows}">SM</td>` : '';
                    const commissionStyle = isLast ? 'style="background-color: #f5f5f5;"' : '';
                    
                        row.innerHTML = `
                        ${monthCell}
                            <td contenteditable="false">${deliveryNo}</td>
                        <td contenteditable="false">${invoiceNo || ''}</td>
                        <td contenteditable="false">${finalInvoiceDate}</td>
                        <td contenteditable="false" ${commissionStyle}>${commission || ''}</td>
                            <td contenteditable="false"></td>
                            <td contenteditable="false"></td>
                            <td contenteditable="false"></td>
                        `;
                    return row;
                };
                
                for (let i = 0; i < maxRows; i++) {
                    const row = createSmRow(i, invoiceRows[i], commissionRows[i]);
                    tbody.appendChild(row);
                    monthRowCount++;
                }
            } else {
                // SM 데이터가 없어도 카테고리2 빈 행은 항상 생성
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td contenteditable="false">SM</td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false" style="background-color: #f5f5f5;"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                `;
                tbody.appendChild(row);
                monthRowCount++;
            }
            
            // 카테고리3 (NT) 처리
            const ntCommission = findNtTotalCommission(creditNoteData, month, currentYear);
            const ntRow = document.createElement('tr');
            ntRow.innerHTML = `
                <td contenteditable="false">NT</td>
                <td contenteditable="false"></td>
                <td contenteditable="false"></td>
                <td contenteditable="false"></td>
                <td contenteditable="false" style="background-color: #f5f5f5;">${ntCommission}</td>
                <td contenteditable="false"></td>
                <td contenteditable="false"></td>
                <td contenteditable="false"></td>
            `;
            tbody.appendChild(ntRow);
            monthRowCount++;
            
            // 카테고리4 (Credit Note) 처리 - 여러 개의 Credit Note 지원
            
            // 해당 월의 모든 Credit Note 찾기
            const monthNumber = getMonthNumber(month);
            const monthCreditNotes = creditNoteData
                .filter(item => {
                    if (!item['c/ndate']) return false;
            
                    const dateParts = item['c/ndate'].split('.');
                    if (dateParts.length < 2) return false;
                    
                        const itemYear = parseInt(dateParts[0]);
                        const itemMonth = parseInt(dateParts[1]);
                    
                    return itemYear === currentYear && itemMonth === monthNumber;
                })
                .map(item => ({
                                cNno: item['c/nno'] || '',
                                cNdate: item['c/ndate'] || ''
                }));
            
            // Credit Note 행들 생성 - Over Payment와 같은 방식으로 rowspan 적용
            if (monthCreditNotes.length > 0) {
                // 데이터 매핑 및 정렬을 한 번에 처리
                const enrichedCreditNotes = monthCreditNotes.map(creditNote => {
                    const item = creditNoteData.find(item => item['c/nno'] === creditNote.cNno);
                    return {
                        ...creditNote,
                        individualCommission: item?.data?.totalcommission || '',
                        cNdollar: item?.['c/ndollar'] || '',
                        cNeuro: item?.['c/neuro'] || '',
                        hasSmOrNt: !!(item?.data?.smtotalcommission || item?.data?.nttotalcommission)
                    };
                }).sort((a, b) => {
                    // totalcommission이 있는 것 먼저
                    const aHasTotal = !!(a.individualCommission && a.individualCommission !== '');
                    const bHasTotal = !!(b.individualCommission && b.individualCommission !== '');
                    
                    if (aHasTotal && !bHasTotal) return -1;
                    if (!aHasTotal && bHasTotal) return 1;
                    
                    // 둘 다 같은 타입이면 날짜순으로 정렬 (일찍이 위로)
                    const aDate = new Date(a.cNdate.replace(/\./g, '-'));
                    const bDate = new Date(b.cNdate.replace(/\./g, '-'));
                    return aDate - bDate;
                });
                
                // 행 생성 함수
                const createCreditNoteRow = (creditNote, index) => {
                    const row = document.createElement('tr');
                    const isFirst = index === 0;
                    const monthCell = isFirst ? `<td rowspan="${enrichedCreditNotes.length}">Credit Note</td>` : '';
                    const euroValue = creditNote.cNeuro;
                    const euroStyle = isFirst ? 'style="border-top: 1.5px solid #000; background-color: #f5f5f5;"' : '';
                    
                    row.innerHTML = `
                        ${monthCell}
                            <td contenteditable="false"></td>
                            <td contenteditable="false">${creditNote.cNno}</td>
                            <td contenteditable="false">${creditNote.cNdate}</td>
                        <td contenteditable="false" ${euroStyle}>${euroValue}</td>
                        <td contenteditable="false">${creditNote.cNdollar && creditNote.cNdollar !== '0' ? creditNote.cNdollar : ''}</td>
                            <td contenteditable="false"><input type="checkbox" class="row-checkbox" data-delivery-no="${creditNote.cNno || ''}" data-month="${month}" data-year="${currentYear}" data-category="Credit Note"></td>
                            <td contenteditable="false"></td>
                        `;
                    return row;
                };
                
                enrichedCreditNotes.forEach((creditNote, index) => {
                    const row = createCreditNoteRow(creditNote, index);
                    tbody.appendChild(row);
                    monthRowCount++;
                });
            } else {
                // Credit Note가 없는 경우 빈 행 생성
                const creditNoteRow = document.createElement('tr');
                creditNoteRow.innerHTML = `
                    <td contenteditable="false">Credit Note</td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false" style="border-top: 1.5px solid #000; background-color: #f5f5f5;"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"><input type="checkbox" class="row-checkbox" data-delivery-no=""></td>
                    <td contenteditable="false"></td>
                `;
                tbody.appendChild(creditNoteRow);
                monthRowCount++;
            }
            
            // 카테고리5 (Over Payment) 처리 - 여러 개의 Over Payment 지원
            const overPaymentItems = findOverPaymentItems(orderData, month, currentYear);
            
            // creditnote.html에서 o/pno 확인하여 추가 Over Payment 로드
            const additionalOverPayments = findAdditionalOverPayments(creditNoteData, overPaymentItems, month, currentYear);
            overPaymentItems.push(...additionalOverPayments);
            
            // Over Payment 행들 생성
            if (overPaymentItems.length > 0) {
                // 데이터 매핑 및 정렬을 한 번에 처리
                const enrichedOverPayments = overPaymentItems.map(item => {
                    // 이미 필터링에서 > 0 조건을 확인했으므로 계산값 사용
                    const piprice = parseFloat(item['p/iprice']) || 0;
                    const piprice2 = parseFloat(item['p/iprice2']) || 0;
                    const invoiceprice = parseFloat(item['invoiceprice']) || 0;
                    const overPaymentValue = piprice + piprice2 - invoiceprice;
                    
                    // o/peuro 값 찾기
                    const creditItem = creditNoteData.find(creditItem => creditItem['o/pno'] === item.invoiceno);
                    const oPeuro = creditItem?.['o/peuro'] || '';
                    
                    // 배경색 설정 (값이 있을 때 연한 초록색)
                    const backgroundColor = (overPaymentValue > 0 && item.deliveryNo && item.deliveryNo.trim() !== '') ? 'background-color: #d4edda;' : '';
                    
                    return {
                        ...item,
                        overPaymentValue,
                        oPeuro,
                        backgroundColor
                    };
                });
                
                // 행 생성 함수
                const createOverPaymentRow = (item, index) => {
                    const row = document.createElement('tr');
                    const isFirst = index === 0;
                    const monthCell = isFirst ? `<td rowspan="${enrichedOverPayments.length}">Over Payment</td>` : '';
                    
                    row.innerHTML = `
                        ${monthCell}
                        <td contenteditable="false">${item.deliveryNo || ''}</td>
                            <td contenteditable="false">${item.invoiceno || ''}</td>
                            <td contenteditable="false">${item.invoicedate || ''}</td>
                        <td contenteditable="false">${item.oPeuro && item.oPeuro !== '0' ? item.oPeuro : ''}</td>
                        <td contenteditable="false" style="${item.backgroundColor}">${item.overPaymentValue.toFixed(2)}</td>
                            <td contenteditable="false">
                            <input type="checkbox" class="row-checkbox" data-delivery-no="${item.invoiceno || ''}" data-month="${month}" data-year="${currentYear}" data-category="Over Payment">
                            </td>
                            <td contenteditable="false">
                                <button type="button" class="top-menu-btn add-btn" style="font-size: 0.8rem; padding: 3px 8px; min-width: 50px; height: 25px;">Add</button>
                            </td>
                        `;
                    return row;
                };
                
                enrichedOverPayments.forEach((item, index) => {
                    const row = createOverPaymentRow(item, index);
                    tbody.appendChild(row);
                    monthRowCount++;
                });
            } else {
                // Over Payment가 없는 경우 빈 행 생성
                const overPaymentRow = document.createElement('tr');
                overPaymentRow.innerHTML = `
                    <td contenteditable="false">Over Payment</td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false">
                        <input type="checkbox" class="row-checkbox" data-delivery-no="" data-month="${month}" data-year="${currentYear}" >
                    </td>
                    <td contenteditable="false">
                        <button type="button" class="top-menu-btn add-btn" style="font-size: 0.8rem; padding: 3px 8px; min-width: 50px; height: 25px;">Add</button>
                    </td>
                `;
                tbody.appendChild(overPaymentRow);
                monthRowCount++;
            }
            
            // 카테고리6 (Less Payment) 처리 - creditnote.html에서 l/pno 확인하여 로드
            const lessPaymentItems = findLessPaymentItems(creditNoteData, month, currentYear);
            
            // Less Payment 행들 생성
            if (lessPaymentItems.length > 0) {
                // 데이터 매핑 및 정렬을 한 번에 처리
                const enrichedLessPayments = lessPaymentItems.map(item => {
                    const lessPaymentValue = parseFloat(item['l/pdollar']) || 0;
                    const lPeuro = item['l/peuro'] || '';
                    const lPdollar = item['l/pdollar'] || '';
                    
                    // 배경색 설정
                    const backgroundColor = (lessPaymentValue > 0 && item.deliveryNo && item.deliveryNo.trim() !== '') ? 'background-color: #d4edda;' : '';
                    
                    return {
                        ...item,
                        lessPaymentValue,
                        lPeuro,
                        lPdollar,
                        backgroundColor
                    };
                });
                
                // 행 생성 함수
                const createLessPaymentRow = (item, index) => {
                    const row = document.createElement('tr');
                    const isFirst = index === 0;
                    const monthCell = isFirst ? `<td rowspan="${enrichedLessPayments.length}">Less Payment</td>` : '';
                    
                    row.innerHTML = `
                        ${monthCell}
                        <td contenteditable="false">${item.deliveryNo || ''}</td>
                            <td contenteditable="false">${item.invoiceno || ''}</td>
                            <td contenteditable="false">${item.invoicedate || ''}</td>
                        <td contenteditable="false" style="${item.backgroundColor}">${item.lPeuro && item.lPeuro !== '0' ? item.lPeuro : ''}</td>
                        <td contenteditable="false">${item.lPdollar && item.lPdollar !== '0' ? item.lPdollar : ''}</td>
                            <td contenteditable="false">
                            <input type="checkbox" class="row-checkbox" data-delivery-no="${item.invoiceno || ''}" data-month="${month}" data-year="${currentYear}" data-category="Less Payment">
                            </td>
                            <td contenteditable="false">
                                <button type="button" class="top-menu-btn add-btn" style="font-size: 0.8rem; padding: 3px 8px; min-width: 50px; height: 25px;">Add</button>
                            </td>
                        `;
                    return row;
                };
                
                enrichedLessPayments.forEach((item, index) => {
                    const row = createLessPaymentRow(item, index);
                    tbody.appendChild(row);
                    monthRowCount++;
                });
            } else {
                // Less Payment 데이터가 없으면 빈 행 생성
                const lessPaymentRow = document.createElement('tr');
                lessPaymentRow.innerHTML = `
                    <td contenteditable="false">Less Payment</td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false"></td>
                    <td contenteditable="false">
                        <input type="checkbox" class="row-checkbox" data-delivery-no="" data-month="${month}" data-year="${currentYear}" data-category="Less Payment" >
                    </td>
                    <td contenteditable="false"></td>
                `;
                tbody.appendChild(lessPaymentRow);
                monthRowCount++;
            }
            
            // 첫 번째 행의 rowspan을 전체 월 행 수로 업데이트
            if (firstRowOfMonth) {
                const firstRowCells = firstRowOfMonth.querySelectorAll('td');
                if (firstRowCells.length > 0) {
                    firstRowCells[0].setAttribute('rowspan', monthRowCount);
                }
            }
            } catch (error) {
                console.error(`월별 처리 중 오류 발생 (${month}):`, error);
                // 에러가 발생해도 다음 월로 계속 진행
            }
        });
    }


    // 행 데이터 추출 함수
    function extractRowData(cells) {
        console.log('extractRowData - cells.length:', cells.length);
        console.log('extractRowData - cells content:', Array.from(cells).map(cell => cell.textContent.trim()));
        
        const isFirstRow = cells.length === 8;
        
        if (isFirstRow) {
            // 첫 번째 행 (rowspan 포함): Company, DeliveryNo, InvoiceNo, InvoiceDate, EURO(€), Dollar($), Check, Action
            const data = {
                deliveryNo: cells[1].textContent.trim(),  // DeliveryNo
                invoiceNo: cells[2].textContent.trim(),   // InvoiceNo
                invoiceDate: cells[3].textContent.trim(), // InvoiceDate
                commission: cells[5].textContent.trim()   // Dollar($)
            };
            console.log('extractRowData - first row data:', data);
            return data;
        } else if (cells.length === 7) {
            // 나머지 행들 (rowspan으로 병합): DeliveryNo, InvoiceNo, InvoiceDate, EURO(€), Dollar($), Check, Action
            const data = {
                deliveryNo: cells[0].textContent.trim(),  // DeliveryNo
                invoiceNo: cells[1].textContent.trim(),   // InvoiceNo
                invoiceDate: cells[2].textContent.trim(), // InvoiceDate
                commission: cells[4].textContent.trim()   // Dollar($)
            };
            console.log('extractRowData - other row data:', data);
            return data;
        }
        
        console.log('extractRowData - no matching row format');
        return null;
    }

    // Add 버튼 클릭 이벤트 리스너 설정 (이벤트 위임 사용)
    function setupAddButtonEventListeners() {
        document.addEventListener('click', async function(event) {
            if (event.target.classList.contains('add-btn')) {
                const row = event.target.closest('tr');
                
                if (row) {
                    const cells = row.querySelectorAll('td');
                    const rowData = extractRowData(cells);
                    
                    if (rowData) {
                        const { deliveryNo, invoiceNo, invoiceDate, commission } = rowData;
                        
                        if (invoiceNo) {
                            await saveOverPaymentToCreditNote(deliveryNo, invoiceNo, invoiceDate, commission);
                        } else {
                            alert('Invoice No를 입력해주세요.');
                        }
                    }
                }
            }
        });
    }

    // Over Payment 데이터를 creditnote.json에 저장하는 함수
    async function saveOverPaymentToCreditNote(deliveryNo, invoiceNo, invoiceDate, commission) {
        try {
            // Over Payment 데이터 생성
            const overPaymentData = {
                "o/pno": invoiceNo,
                "o/pdate": invoiceDate || "",
                "o/pdollar": parseFloat(commission) || 0
            };
            
            // API 호출
            const saveResponse = await fetch('/api/creditnote', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(overPaymentData)
            });
            
            if (saveResponse.ok) {
                alert(`Over Payment 데이터가 저장되었습니다.\no/pno: ${invoiceNo}\no/pdate: ${invoiceDate || ''} \no/pdollar: ${commission || 0}`);
                // 테이블 새로고침
                await generateCreditNoteTable();
            } else {
                const errorResult = await saveResponse.json();
                alert(`데이터 저장에 실패했습니다: ${errorResult.message}`);
            }
            
        } catch (error) {
            alert('데이터 저장 중 오류가 발생했습니다: ' + error.message);
        }
    }

    // 체크박스 이벤트 리스너 설정 (is used 기능만 유지)
    function setupCheckboxEventListeners() {
        document.addEventListener('change', async function(event) {
            if (event.target.classList.contains('row-checkbox')) {
                const month = event.target.getAttribute('data-month');
                const year = parseInt(event.target.getAttribute('data-year'));
                const deliveryNo = event.target.getAttribute('data-delivery-no');
                const isChecked = event.target.checked;
                
                // is used 상태만 저장 (is covered 제외)
                await saveIsusedState(month, year, deliveryNo, isChecked);
            }
        });
    }
    
    // is used 상태 저장 함수
    async function saveIsusedState(month, year, deliveryNo, isChecked) {
        try {
            const response = await fetch('/api/creditnote');
            if (!response.ok) {
                throw new Error('Credit Note 데이터 로드 실패');
            }
            
            const creditNoteData = await response.json();
            const category = document.querySelector(`[data-month="${month}"][data-year="${year}"][data-delivery-no="${deliveryNo}"]`).getAttribute('data-category');
            
            if (category === 'Less Payment') {
                await handleLessPaymentCategory(creditNoteData, deliveryNo, isChecked);
            } else {
                await handleOtherCategories(creditNoteData, deliveryNo, isChecked);
            }
        } catch (error) {
            console.error('상태 저장 중 오류:', error);
        }
    }
    
    // Less Payment 카테고리 처리
    async function handleLessPaymentCategory(creditNoteData, deliveryNo, isChecked) {
        if (!deliveryNo) return;
        
        const targetItem = creditNoteData.find(item => item['l/pno'] === deliveryNo);
        if (!targetItem) {
            console.log(`Less Payment ${deliveryNo}를 찾을 수 없음`);
            return;
        }
        
        const saveResponse = await fetch('/api/creditnote', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'updateField',
                identifier: deliveryNo,
                field: 'isused',
                value: isChecked
            })
        });
        
        if (saveResponse.ok) {
            console.log(`Less Payment ${deliveryNo} isused 상태가 ${isChecked}로 업데이트됨`);
        } else {
            console.error('Less Payment 상태 저장 실패');
        }
    }
    
    // 기타 카테고리 처리 (Over Payment, Credit Note)
    async function handleOtherCategories(creditNoteData, deliveryNo, isChecked) {
        if (!deliveryNo) return;
        
        const targetItem = creditNoteData.find(item => 
            item['o/pno'] === deliveryNo || item['c/nno'] === deliveryNo
        );
        
        if (!targetItem) {
            console.log(`Credit Note ${deliveryNo}를 찾을 수 없음`);
            return;
        }
        
        const saveResponse = await fetch('/api/creditnote', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'updateField',
                identifier: deliveryNo,
                field: 'isused',
                value: isChecked
            })
        });
        
        if (saveResponse.ok) {
            const itemType = targetItem['o/pno'] ? 'Over Payment' : 'Credit Note';
            console.log(`${itemType} ${deliveryNo} isused 상태가 ${isChecked}로 업데이트됨`);
        } else {
            console.error('isused 상태 저장 실패');
        }
    }
    
    // 체크박스 상태 복원 함수
    async function restoreCheckboxStates() {
        try {
            const response = await fetch('/api/creditnote');
            if (!response.ok) return;
            
            const creditNoteData = await response.json();
            const checkboxes = document.querySelectorAll('.row-checkbox');
            
            // 데이터 전처리: 날짜별로 그룹화
            const dataByMonth = preprocessCreditNoteData(creditNoteData);
            
            checkboxes.forEach(checkbox => {
                const month = checkbox.getAttribute('data-month');
                const year = parseInt(checkbox.getAttribute('data-year'));
                const deliveryNo = checkbox.getAttribute('data-delivery-no');
                const category = checkbox.getAttribute('data-category');
                
                if (!month || isNaN(year)) return;
                
                const monthNumber = getMonthNumber(month);
                const isChecked = getCheckboxState(dataByMonth, category, monthNumber, year, deliveryNo, creditNoteData);
                checkbox.checked = isChecked;
            });
        } catch (error) {
            console.error('체크박스 상태 복원 중 오류:', error);
        }
    }
    
    // 데이터 전처리 함수
    function preprocessCreditNoteData(creditNoteData) {
        const dataByMonth = {};
        
        creditNoteData.forEach(item => {
            if (!item['c/ndate']) return;
            
                            const dateParts = item['c/ndate'].split('.');
            if (dateParts.length < 2) return;
            
                                const itemYear = parseInt(dateParts[0]);
                                const itemMonth = parseInt(dateParts[1]);
            const key = `${itemYear}-${itemMonth}`;
            
            if (!dataByMonth[key]) {
                dataByMonth[key] = [];
            }
            dataByMonth[key].push(item);
        });
        
        return dataByMonth;
    }
    
    // 체크박스 상태 확인 함수
    function getCheckboxState(dataByMonth, category, monthNumber, year, deliveryNo, creditNoteData) {
        const key = `${year}-${monthNumber}`;
        const monthData = dataByMonth[key] || [];
        
        switch (category) {
            case 'Credit Note':
                return monthData.some(item => item.isused === true);
                
            case 'Over Payment':
                return deliveryNo && creditNoteData.some(item => 
                    item['o/pno'] === deliveryNo && item.isused === true
                );
                
             case 'SM':
                 // SM 카테고리는 체크박스가 없으므로 항상 false
                 return false;
                
            case 'Less Payment':
                return deliveryNo && creditNoteData.some(item => 
                    item['l/pno'] === deliveryNo && item.isused === true
                );
                
            default:
                return false;
        }
    }

    // 페이지 로드 시 초기화
    document.addEventListener('DOMContentLoaded', async function() {
        // 테이블 생성
        await generateCreditNoteTable();
        
        // 이벤트 리스너 설정
        setupCheckboxEventListeners();
        setupAddButtonEventListeners();
        setupExpandButton();
        
        // 체크박스 상태 복원
        await restoreCheckboxStates();
    });

    // 확장/축소 기능
    function setupExpandButton() {
        const expandButton = document.getElementById("expandButton");
                const detailArea = document.getElementById("detailButtonArea");
        
        if (expandButton && detailArea) {
            expandButton.addEventListener("click", () => {
                const isExpanded = detailArea.style.display !== "none";
                
                detailArea.style.display = isExpanded ? "none" : "flex";
                expandButton.classList.toggle("expanded", !isExpanded);
                expandButton.textContent = isExpanded ? "▼" : "▲";
            });
        }
    }
    
</script>

</body>
</html>